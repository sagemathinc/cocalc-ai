import { spawn, spawnSync, type ChildProcess } from "node:child_process";
import {
  chmodSync,
  existsSync,
  mkdirSync,
  readFileSync,
  writeFileSync,
  readdirSync,
  rmSync,
} from "node:fs";
import { createHash } from "node:crypto";
import { homedir } from "node:os";
import { dirname, join } from "node:path";
import getLogger from "@cocalc/backend/logger";

const logger = getLogger("database:postgres:dev");

type LocalPostgresInfo = {
  dataDir: string;
  socketDir: string;
  user: string;
  database: string;
  pidFile: string;
  child: ChildProcess;
};

type PgBinaries = {
  postgres: string;
  initdb: string;
  psql: string;
  createuser: string;
  createdb: string;
  pgIsReady?: string;
  pgCtl?: string;
};

let running: LocalPostgresInfo | null = null;
let stopping = false;

function which(cmd: string): string | null {
  const paths = (process.env.PATH ?? "").split(":");
  for (const p of paths) {
    const candidate = join(p, cmd);
    if (existsSync(candidate)) return candidate;
  }
  return null;
}

function requireBinary(cmd: string): string {
  const found = which(cmd);
  if (!found) {
    throw new Error(`missing '${cmd}' (install postgres client/server packages)`);
  }
  return found;
}

function resolvePgBinaries(): PgBinaries {
  const pgConfig = which("pg_config");
  if (pgConfig) {
    const bindir = runQuiet(pgConfig, ["--bindir"]).trim();
    return {
      postgres: join(bindir, "postgres"),
      initdb: join(bindir, "initdb"),
      psql: join(bindir, "psql"),
      createuser: join(bindir, "createuser"),
      createdb: join(bindir, "createdb"),
      pgIsReady: existsSync(join(bindir, "pg_isready"))
        ? join(bindir, "pg_isready")
        : undefined,
      pgCtl: existsSync(join(bindir, "pg_ctl")) ? join(bindir, "pg_ctl") : undefined,
    };
  }
  return {
    postgres: requireBinary("postgres"),
    initdb: requireBinary("initdb"),
    psql: requireBinary("psql"),
    createuser: requireBinary("createuser"),
    createdb: requireBinary("createdb"),
    pgIsReady: which("pg_isready") ?? undefined,
    pgCtl: which("pg_ctl") ?? undefined,
  };
}

function resolveDataDir(): string {
  const data = process.env.DATA ?? join(process.cwd(), "data");
  return join(data, "postgres");
}

function resolveSocketDir(dataDir: string): string {
  const override = process.env.COCALC_LOCAL_PG_SOCKET_DIR;
  if (override) return override;
  const runtime = process.env.XDG_RUNTIME_DIR;
  const base = runtime ?? join(homedir(), ".local", "share");
  const suffix = createHash("sha256").update(dataDir).digest("hex").slice(0, 8);
  return join(base, "cocalc", `pg-${suffix}`);
}

function resolveEnvFile(): string {
  const override = process.env.COCALC_LOCAL_PG_ENV_FILE;
  if (override) return override;
  const dataRoot = process.env.COCALC_DATA_DIR ?? process.env.DATA ?? join(process.cwd(), "data");
  return join(dataRoot, "local-postgres.env");
}

function writeEnvFile({
  socketDir,
  user,
  database,
}: {
  socketDir: string;
  user: string;
  database: string;
}): string | undefined {
  const path = resolveEnvFile();
  try {
    ensureDir(dirname(path), 0o700);
    const dataDir = process.env.COCALC_DATA_DIR ?? process.env.DATA;
    const secretsDir = process.env.SECRETS ?? (dataDir ? join(dataDir, "secrets") : undefined);
    const secretSettingsKeyPath =
      process.env.COCALC_SECRET_SETTINGS_KEY_PATH ??
      (secretsDir ? join(secretsDir, "server-settings-key") : undefined);
    const contents = [
      "# Auto-generated by ensureLocalPostgres",
      dataDir ? `export DATA=${dataDir}` : undefined,
      dataDir ? `export COCALC_DATA_DIR=${dataDir}` : undefined,
      secretsDir ? `export SECRETS=${secretsDir}` : undefined,
      secretSettingsKeyPath
        ? `export COCALC_SECRET_SETTINGS_KEY_PATH=${secretSettingsKeyPath}`
        : undefined,
      `export PGHOST=${socketDir}`,
      `export PGUSER=${user}`,
      `export PGDATABASE=${database}`,
      "",
    ]
      .filter(Boolean)
      .join("\n");
    writeFileSync(path, contents, { mode: 0o600 });
    chmodSync(path, 0o600);
    return path;
  } catch (err) {
    logger.warn("failed to write local postgres env file", { path, err });
    return undefined;
  }
}

function ensureDir(path: string, mode = 0o700): void {
  mkdirSync(path, { recursive: true, mode });
  try {
    chmodSync(path, mode);
  } catch {
    // best effort; permissions might already be correct
  }
}

function runSync(cmd: string, args: string[], env?: NodeJS.ProcessEnv): void {
  const res = spawnSync(cmd, args, {
    env: { ...process.env, ...env },
    stdio: "inherit",
  });
  if (res.status !== 0) {
    throw new Error(`${cmd} failed with status ${res.status}`);
  }
}

function runQuiet(cmd: string, args: string[], env?: NodeJS.ProcessEnv): string {
  const res = spawnSync(cmd, args, {
    env: { ...process.env, ...env },
    encoding: "utf8",
  });
  if (res.status !== 0) {
    const stderr = res.stderr?.toString().trim() ?? "";
    const stdout = res.stdout?.toString().trim() ?? "";
    throw new Error(`${cmd} failed (${res.status}): ${stderr || stdout}`);
  }
  return (res.stdout ?? "").toString();
}

function ensureConfig(dataDir: string, socketDir: string): void {
  const hba = join(dataDir, "pg_hba.conf");
  if (existsSync(hba)) {
    writeFileSync(
      hba,
      [
        "# cocalc-dev",
        "local all all trust",
        "",
      ].join("\n"),
    );
  }

  const conf = join(dataDir, "postgresql.conf");
  let contents = "";
  if (existsSync(conf)) {
    contents = readFileSync(conf, "utf8");
  }
  if (!contents.includes("# cocalc-dev")) {
    contents += [
      "",
      "# cocalc-dev",
      `unix_socket_directories = '${socketDir}'`,
      "listen_addresses = ''",
      "max_connections = 1000",
      "",
    ].join("\n");
    writeFileSync(conf, contents);
  }
}

function waitForReady(
  socketDir: string,
  user: string,
  pgIsReady?: string,
  psqlBin?: string,
): void {
  const deadline = Date.now() + 15000;
  while (Date.now() < deadline) {
    try {
      if (pgIsReady) {
        const res = spawnSync(
          pgIsReady,
          ["-h", socketDir, "-U", user],
          { encoding: "utf8" },
        );
        if (res.status === 0) return;
      } else {
        runQuiet(psqlBin ?? "psql", [
          "-h",
          socketDir,
          "-U",
          user,
          "-d",
          "postgres",
          "-tAc",
          "SELECT 1",
        ]);
        return;
      }
    } catch {
      // ignore until timeout
    }
  }
  throw new Error("postgres did not become ready in time");
}

function isSocketActive(
  socketDir: string,
  user: string,
  pgIsReady?: string,
): boolean {
  if (!pgIsReady) return false;
  const res = spawnSync(pgIsReady, ["-h", socketDir, "-U", user], {
    encoding: "utf8",
  });
  return res.status === 0 || res.status === 1;
}

function ensureRoleAndDb(
  socketDir: string,
  adminUser: string,
  bins: PgBinaries,
): void {
  const roleCheck = runQuiet(bins.psql, [
    "-h",
    socketDir,
    "-U",
    adminUser,
    "-d",
    "postgres",
    "-tAc",
    "SELECT 1 FROM pg_roles WHERE rolname='smc';",
  ]);
  if (!roleCheck.trim()) {
    runSync(bins.createuser, ["-h", socketDir, "-U", adminUser, "-sE", "smc"]);
  }

  const dbCheck = runQuiet(bins.psql, [
    "-h",
    socketDir,
    "-U",
    adminUser,
    "-d",
    "postgres",
    "-tAc",
    "SELECT 1 FROM pg_database WHERE datname='smc';",
  ]);
  if (!dbCheck.trim()) {
    runSync(bins.createdb, ["-h", socketDir, "-U", adminUser, "-O", "smc", "smc"]);
  }
}

function stopLocalPostgres(): void {
  if (!running || stopping) return;
  stopping = true;
  try {
    const pgCtl = which("pg_ctl");
    if (pgCtl) {
      spawnSync(pgCtl, ["-D", running.dataDir, "-m", "fast", "stop"]);
    } else {
      running.child.kill("SIGTERM");
    }
  } catch (err) {
    logger.warn("failed to stop local postgres", { err });
  } finally {
    stopping = false;
  }
}

export async function ensureLocalPostgres(opts?: {
  enabled?: boolean;
  logExports?: boolean;
}): Promise<LocalPostgresInfo | null> {
  if (running) return running;
  if (!opts?.enabled) return null;
  if (process.env.COCALC_PRODUCT === "rocket") return null;
  if (process.env.COCALC_ROCKET_CONTROL_PLANE === "yes") return null;

  const bins = resolvePgBinaries();

  const dataDir = resolveDataDir();
  let socketDir = resolveSocketDir(dataDir);
  ensureDir(dataDir, 0o700);

  const adminUser = process.env.USER ?? "postgres";
  const pgVersionFile = join(dataDir, "PG_VERSION");
  if (!existsSync(pgVersionFile)) {
    if (isSocketActive(socketDir, adminUser, bins.pgIsReady)) {
      const altSocketDir = `${socketDir}-${process.pid}`;
      logger.warn("socket already active; using a fresh socket dir", {
        socketDir,
        altSocketDir,
      });
      socketDir = altSocketDir;
    }
    ensureDir(socketDir, 0o700);
    const entries = readdirSync(dataDir).filter((entry) => entry !== "lost+found");
    if (entries.length > 0) {
      logger.warn("clearing non-postgres data dir before initdb", {
        dataDir,
        entries,
      });
      for (const entry of entries) {
        rmSync(join(dataDir, entry), { recursive: true, force: true });
      }
    }
    logger.info("initializing local postgres", { dataDir });
    runSync(bins.initdb, ["-D", dataDir, "-U", adminUser, "--auth=trust"]);
    ensureConfig(dataDir, socketDir);
  } else {
    ensureDir(socketDir, 0o700);
    ensureConfig(dataDir, socketDir);
  }

  logger.info("starting local postgres", { dataDir, socketDir });
  const child = spawn(bins.postgres, ["-D", dataDir, "-k", socketDir], {
    stdio: "ignore",
  });

  waitForReady(socketDir, adminUser, bins.pgIsReady, bins.psql);
  ensureRoleAndDb(socketDir, adminUser, bins);

  process.env.PGHOST = socketDir;
  process.env.PGUSER = "smc";
  process.env.PGDATABASE ??= "smc";
  const envFile = writeEnvFile({
    socketDir,
    user: process.env.PGUSER,
    database: process.env.PGDATABASE,
  });

  if (opts?.logExports) {
    console.log(`export PGHOST=${socketDir}`);
    console.log("export PGUSER=smc");
    console.log(`export PGDATABASE=${process.env.PGDATABASE}`);
    if (envFile) {
      console.log(`# local postgres env file: ${envFile}`);
      console.log(`# usage: source ${envFile}`);
    }
  }

  const info: LocalPostgresInfo = {
    dataDir,
    socketDir,
    user: "smc",
    database: "smc",
    pidFile: join(dataDir, "postmaster.pid"),
    child,
  };
  running = info;

  const stop = () => stopLocalPostgres();
  process.once("exit", stop);
  process.once("SIGINT", () => {
    stop();
    process.exit(0);
  });
  process.once("SIGTERM", () => {
    stop();
    process.exit(0);
  });

  return info;
}

export async function runLocalPostgresStandalone(): Promise<void> {
  const info = await ensureLocalPostgres({ enabled: true, logExports: true });
  if (!info) {
    throw new Error("local postgres could not be started");
  }
  // Keep the process alive while postgres runs.
  await new Promise<void>(() => undefined);
}
